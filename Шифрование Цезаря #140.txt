Шифрование Цезаря #140
Этот способ шифрования использовал римский полководец Гай Юлий Цезарь для секретной переписки со своими генералами.

Для того, чтобы получить зашифрованное сообщение, каждый символ в тексте заменяется символом, находящимся на постоянном числе позиций левее или правее него в алфавите.

Например, при сдвиге вправо на 1, А будет заменена на Б, Б станет В, и так далее. Последняя буква алфавита Я будет заменена на первую А.

Сдвиг принято называть ключом и обозначать буквой k. Для примера зашифруем весь алфавит ключом k=3.

Буква «Е» «сдвигается» на три буквы вперёд и становится буквой «З». Твёрдый знак, перемещённый на три буквы вперёд, становится буквой «Э», буква «Я», перемещённая на три буквы вперёд, становится буквой «В», и так далее. В результате из исходного алфавита

А Б В Г Д Е Ё Ж З И Й К Л М Н О П Р С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я
получается зашифрованный

Г Д Е Ё Ж З И Й К Л М Н О П Р С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я А Б В 
В этом уроке нужно написать программу с функцией encrypt. Эта функция должна принимать два аргумента — исходную строку s и ключ k.

Функция encrypt должна шифровать исходную строку s c ключом k. При этом, шифруются только символы, которые есть в алфавите. Знаки препинания, пробелы и другие символы функция должна оставлять «как есть». Исходная строка должна быть преобразована к верхнему регистру. То есть, в результате шифрования строки Привет world! с k=5 должно получится ФХНЖЙЧ WORLD!. Ключ шифрования может быть каким угодно большим числом.

Все, что нужно для решения этой задачи вы уже знаете, но небольшая подсказка не помешает: используйте остаток от деления и строку, содержащую алфавит.

letters = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"
При отрицательном значении аргумента k функция должна сдвигать символы не вправо, а влево. Не забудьте проверить это.

Если все сделано правильно, то при таком использовании encrypt

message = "Привет world!"
encrypted_message = encrypt(message, 5)
decrypted_message = encrypt(encrypted_message, -5)
print(encrypted_message)
print(decrypted_message)
экран должно быть выведено

ФХНЖЙЧ WORLD!
ПРИВЕТ WORLD!
То есть, первый вызов encrypt шифрует строку, а второй, с «минус» k расшифровывает.


Наше решение
Вариант решения с использованием цикла по всей строке для шифрования

def encrypt(message, k):
    letters = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"
    message = message.upper()
    result = ''
    for i in message:
        index = letters.find(i)
        if index != -1:
            # остаток от деления тут используется для того, 
            # чтобы не было выхода за пределы строки letters
            # и не возникала ошибка IndexError
            result += letters[(index + k) % len(letters)]
        else:
            result += i
    return result
Вариант решения с использованием метода строк transtab

def encrypt(message, k):
    letters = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"
    message = str(message).upper()
    # в этой строке мы создаем сдвинутый на значение k алфавит
    # то есть, например, при ключе 3 алфавиту
    # АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ
    # будет соответствовать
    # ЭЮЯАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬ
    letters_tmp = letters[k % 33:] + letters[0:k % 33]
    # создание таблицы переводов для строки. Каждой
    # букве letters будет соответствовать буква из letters_tmp
    transtab = str.maketrans(letters, letters_tmp)
    # метод translate заменит все символы в строке согласно
    # таблице переводов transtab
    return message.translate(transtab)